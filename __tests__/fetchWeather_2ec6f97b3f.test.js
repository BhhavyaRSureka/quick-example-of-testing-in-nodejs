// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeTesting using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=fetchWeather_8dcf21317f
ROOST_METHOD_SIG_HASH=fetchWeather_2ec6f97b3f


*/

// ********RoostGPT********
// __tests__/fetch-weather.test.js

const { fetchWeather } = require('../fetch-weather');

jest.mock('request', () => ({
  get: jest.fn(),
}));

const request = require('request');

describe('fetchWeather', () => {
  const location = 'London';
  const appId = 'aa0f1b0be45dca476178787f941c76dc';
  const url = `http://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${appId}`;

  let processResults;

  beforeEach(() => {
    processResults = jest.fn();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should call the callback with processed results on a successful fetch', async () => {
    const mockApiResponse = { weather: [{ main: 'Clear', description: 'clear sky' }], main: { temp: 280.32 } };
    request.get.mockImplementation((url, callback) => {
      callback(null, { statusCode: 200 }, JSON.stringify(mockApiResponse));
    });
    processResults.mockReturnValue('Processed Results Mock');

    await fetchWeather(location, appId, processResults);

    expect(processResults).toHaveBeenCalledWith(mockApiResponse);
  });

  it('should handle the error when the request fails', async () => {
    const mockError = new Error('Network error');
    request.get.mockImplementation((url, callback) => {
      callback(mockError, null, null);
    });

    await fetchWeather(location, appId, processResults).catch((error) => {
      expect(error).toBeInstanceOf(Error);
    });

    expect(processResults).not.toHaveBeenCalled();
  });

  it('should handle the scenario where the response status code is not 200', async () => {
    request.get.mockImplementation((url, callback) => {
      callback(null, { statusCode: 500 }, null);
    });

    fetchWeather(location, appId, processResults).catch((error) => {
      expect(error).toBeInstanceOf(Error);
    });
  });

  it('should not call the callback if no response is received', async () => {
    request.get.mockImplementation((url, callback) => {
      callback(null, null, null);
    });

    await fetchWeather(location, appId, processResults);

    expect(processResults).not.toHaveBeenCalled();
  });
});

